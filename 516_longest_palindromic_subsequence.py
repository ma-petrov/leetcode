# https://leetcode.com/problems/longest-palindromic-subsequence/


class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        # Нужно с левого и правого края проверять одинаковость
        # символов. Если символы i, j не одинаковы - есть 2 варината, вырезать
        # символ i или символ j. Для двух вариантов нужно посчитать длину и
        # выбрать среди них наибольшую. Получается дерево решений, которое
        # ветвится там, где символы неодинаковы.
        #
        # Задача сводится к двумерной динамической. Для снижения когнитивной
        # нагрузки можно представить, что сравниваются не левый и правый
        # символы, а символ прямой и обратной строк, например abc и cba.
        #
        # TODO: математическое обоснование.
        # TODO: как перейти от рассуждения про рекурсивное решение к решению
        # динамическим программированием.
        # 
        # Строка - abac
        # В строках - символы в прямом порядке (до запятой)
        # В столбцах - сиволы в обратном порядке (после запятой)
        #
        # a, c | a, a | a, b | a, a
        # b, c | b, a | b, b | b, a 
        # a, c | a, a | a, b | a, a
        # c, c | c, a | c, b | c, a
        #
        # 0 0 0 0 0
        # 0 0 1 1 1
        # 0 0 1 2 2
        # 0 1 1 2 2
        # 0 1 1 2 2
        #

        lengths = [[0] * (len(s) + 1) for _ in range(len(s) + 1)]

        for i in range(len(s)):
            for j in range(len(s)):
                
                if s[i] == s[len(s) - j - 1]:
                    lengths[i + 1][j + 1] = lengths[i][j] + 1
                
                else:
                    lengths[i + 1][j + 1] = max(
                        lengths[i + 1][j],
                        lengths[i][j + 1],
                    )

        return lengths[len(s)][len(s)]
