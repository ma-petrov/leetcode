class Solution:
    digits = "0123456"

    def numDecodings(self, s: str) -> int:
        # Хранение промежуточных решений. i-ый элемент содержит решение для
        # подстроки s[i:-1]
        num_decodings = {len(s): 1}

        # Промежуеточные решения вычисляются от конца строки к началу. Это
        # связано с 0. При вычислении с начала строки нельзя корректно оценить,
        # можно или нельзя включать 0 в текущий код буквы.
        
        # i-ый элемент - левая цифра, i + 1 - правая цифра.
        for i in range(len(s) - 1, -1, -1):

            # 1. Подсчет кол-во вариантов для подстроки s[i: len(s)], для
            # случая, когда первый символ кодируется одной цифрой.

            # Если эта цифра 0, тогда для этой подстроки будет 0 вариантов,
            # потому что букв с кодом 0 не существует.
            if s[i] == "0":
                num_decodings[i] = 0
            
            # Если цифра отлична от нуля, то для строки s[i: len(s)] будет
            # столько же вариантов, сколько и для строки s[i + 1: len(s)],
            # когда первый символ кодируется одной цифрой.
            else:
                num_decodings[i] = num_decodings[i + 1]

            # 2. Подсчет кол-во вариантов для подстроки s[i: len(s)], для
            # случая, когда первый символ кодируется двумя цифрами.
            # Если подстроку s[i: len(s)] можно начать с символа длиной в две
            # цифры, то тогда к изначальному кол-ву вариантов нужно добавить
            # кол-во вариантов для подстроки s[i + 2: len(s)]
            if i + 1 < len(s) and self.is_letter(s[i:i + 2]):
                num_decodings[i] += num_decodings[i + 2]
        
        return num_decodings[0]
    
    def is_letter(self, code: str) -> bool:
        # Проверяет, является ли строка длиной 2 символа кодом буквы (число
        # от 10 до 26).

        assert len(code) == 2
        return code[0] == "1" or code[0] == "2" and code[1] in self.digits
