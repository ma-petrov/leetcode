class Solution:
    def canJump(self, nums: list[int]) -> bool:

        # В элменте с индексом i хранится индекс самой дальней ячейки,
        # до которой можно допрыгнуть из i.
        max_jump = [0] * len(nums)
        max_jump[0] = nums[0]

        for i in range(1, len(nums)):
            # Дисклеймер - под предыдущей ячейкой понимается та ячейка, из
            # которой можно допрыгнуть дальше всего. Если из ячейки n - k можно
            # допрыгнуть дальше чем из ячейки n, то в max_jump[n] будет
            # расстояние, на которое можно допрыгнуть из ячейки n - k.

            # Если индекс текущей ячейки больше, чем расстояние, на которое
            # можно допрыгнуть из предыдущей ячейки, то нельзя дпрыгать до
            # конца.
            if i > max_jump[i - 1]:
                return False

            # Иначе, самое дальнее расстояение, на которое можно допрыгнуть
            # из текущей ячейки, это наибольшее среди прыжка из текущей ячейки
            # или расстояния, до которого можно допрыгнуть из предыдущей.
            max_jump[i] = max(i + nums[i], max_jump[i - 1])
        
        return True
